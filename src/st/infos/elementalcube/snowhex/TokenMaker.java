package st.infos.elementalcube.snowhex;

import java.awt.PopupMenu;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.swing.JComponent;

import st.infos.elementalcube.snowhex.Token.Level;
import st.infos.elementalcube.snowhex.parser.Ant1TokenMaker;
import st.infos.elementalcube.snowhex.parser.Ant3TokenMaker;
import st.infos.elementalcube.snowhex.parser.CORTokenMaker;
import st.infos.elementalcube.snowhex.parser.GZTokenMaker;
import st.infos.elementalcube.snowhex.parser.SNITokenMaker;
import st.infos.elementalcube.snowhex.parser.gif.GIFTokenMaker;
import st.infos.elementalcube.snowhex.parser.png.PNGTokenMaker;
import st.infos.elementalcube.snowhex.ui.HexPanel;
import st.infos.elementalcube.snowylangapi.Lang;

public abstract class TokenMaker implements TokenTypes {
	private static HashMap<String, Class<? extends TokenMaker>> subclasses = new HashMap<>();
	
	// token pooling
	private ArrayList<Token> cache = new ArrayList<>();
	private int nextAvailableToken = 0;
	
	static {
		subclasses.put("sni", SNITokenMaker.class);
		subclasses.put("gif", GIFTokenMaker.class);
		subclasses.put("ant3", Ant3TokenMaker.class);
		subclasses.put("ant1", Ant1TokenMaker.class);
		subclasses.put("cor", CORTokenMaker.class);
		subclasses.put("png", PNGTokenMaker.class);
		subclasses.put("gz", GZTokenMaker.class);
		// TODO subclasses.put("ser", SERTokenMaker.class);
	}
	
	/**
	 * Create the list of syntactic tokens.
	 * 
	 * A same byte can be a part of multiple tokens, usually a secondary (background, bigger length), and a primary (foreground, more restrained in length)
	 * 
	 * @param array the bytes in the file
	 * @return a list of tokens in the file
	 */
	public abstract List<Token> generateTokens(byte[] array);
	
	/**
	 * Create a Token instance. If you use a custom Token class, override this method.
	 * @return an uninitialized token
	 */
	public Token allocToken() {
		return new TokenImpl();
	}
	
	public Token createToken(int type, int offset, int length) {
		return createToken(type, offset, length, null, null);
	}
	
	public Token createToken(int type, int offset, int length, String desc, Level lvl) {
		assert nextAvailableToken <= cache.size();
		if (nextAvailableToken == cache.size()) {
			cache.add(allocToken());
		}
		Token c = cache.get(nextAvailableToken);
		c.init(type, offset, length, desc, lvl);
		nextAvailableToken++;
		return c;
	}
	
	public void invalidateTokenPool() {
		nextAvailableToken = 0;
	}
	
	/**
	 * Returns a short name for the language (ex: sni, gif, png...).
	 * This is usually also the file extension
	 * 
	 * @return the simple name of the language
	 */
	public abstract String getName();
	
	public String getLocalizedName() {
		return Lang.getString("parser." + getName());
	}
	
	public String notice(String type, Object... params) {
		return Lang.getString("parser." + getName() + "." + type, params);
	}
	
	/**
	 * Returns the object to show as a preview.<br/>
	 * If null, shows nothing.<br/>
	 * If instanceof Image, shows the image.
	 * 
	 * @return the object to show to the user
	 */
	public abstract Object getDump(byte[] array);

	/**
	 * Returns the closest token at the given position, to be shown in the properties panel
	 * @param array the bytes in the file 
	 * @param tokens the tokens generated by this token maker
	 * @param offset the offset into the byte array
	 * @return the closest token to the given offset, or null if there are none
	 */
	public Token getClosestToken(byte[] array, List<Token> tokens, int offset) {
		Iterator<Token> filtered = tokens.stream().filter(t -> t.at(offset)).iterator();
		Token closest = null;
		int length = Integer.MAX_VALUE;
		while (filtered.hasNext()) {
			Token t = filtered.next();
			if (t.getLength() <= length) {
				closest = t;
				length = t.getLength();
			}
		}
		return closest;
	}
	
	/**
	 * Returns the properties view to show/edit a token, or null for the default.
	 * You should access the HexPanel's bytes, token list, cursor position and closest token to show an adequate view.
	 * The method is called each time one of those change.
	 * @param panel the editor of the file
	 * @return the token editor panel, or null
	 * @apiNote this method will be called very often, you should cache the result, using an instance property (1 TokenMaker instance = 1 HexPanel)
	 */
	public JComponent getTokenProperties(HexPanel panel) {
		return null;
	}

	/**
	 * Called when a right click menu will be shown. The TokenMaker may add custom actions to the menu.
	 * By default, before this method is called, it contains the classic copy-cut-paste actions.
	 * They shouldn't be removed, but new actions can be added before or after, with a separator.
	 * 
	 * @param panel the editor of the file
	 * @param menu the popup to be shown (note it is an AWT PopupMenu as they look better)
	 */
	public void willShowPopup(HexPanel panel, PopupMenu menu) {}
	
	// Static utilities
	
	public static short toShort(byte b1, byte b2, ByteOrder bo) {
		ByteBuffer bb = ByteBuffer.allocate(2);
		bb.order(bo);
		bb.put(b1);
		bb.put(b2);
		return bb.getShort(0);
	}
	
	public static String getHexString(String hexString, int len) {
		StringBuilder sb = new StringBuilder(hexString);
		while (sb.length() < len)
			sb.insert(0, '0');
		return sb.toString();
	}
	
	public static void registerTokenMaker(String ext, Class<? extends TokenMaker> c) {
		subclasses.put(ext.toLowerCase(), c);
	}
	
	public static TokenMaker getTokenMaker(String ext) {
		if (ext == null) return null;
		Class<? extends TokenMaker> c = subclasses.get(ext.toLowerCase());
		if (c != null) {
			try {
				return c.getDeclaredConstructor().newInstance();
			} catch (ReflectiveOperationException e) {
				System.err.println("Unable to initialize TokenMaker: " + c);
				e.printStackTrace();
			}
		}
		return null;
	}

	public static Set<String> getParsers() {
		return subclasses.keySet();
	}
}
